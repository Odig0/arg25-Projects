{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"12688665003504956387","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"hash_path","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"expected_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"expected_nft_metadata_cid_hash","type":{"kind":"field"},"visibility":"private"},{"name":"ip_nft_data","type":{"kind":"struct","path":"data_types::IPNftData","fields":[{"name":"nft_owner","type":{"kind":"field"}},{"name":"nft_token_id","type":{"kind":"field"}},{"name":"nft_metadata_cid","type":{"kind":"string","length":46}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"data_types::RevealedData","fields":[{"name":"nullifier","type":{"kind":"field"}},{"name":"nft_metadata_cid_hash","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7ZjBTiM5FEX/Jess6l3bZZtfaSEUIN2KFAWUhpZGiH8fV3ycNDNyKUoU9aY3PALxKde1j8uuj8Xz+vH9x8Nm9/3l5+Lu28ficb/Zbjc/HrYvT6u3zcuu/PVjMUw/kl/c2XKRQi1jLbGWVEs+lDzUYrWoFldLpeRKyZWSKyVXSq4UGwaqUUV1VE8N1JEaqYkKz+AZPINn8AyewTN4Bs/gGTzBEzzBEzzBEzzBEzzBEzwHz8Fz8Bw8B8/Bc/AcPAfPwfPwPDwPz8Pz8Dw8D8/D8/A8vAAvwAvwArwAL8AL8AK8AC/AG+GN8EZ4I7wR3lh4mupIjdTC02f55e/s/Ds7/+jsNGanMTuN2Xmo8CK8CC/Ci/AivAgvwovwIrwIL8FL8BK8BA8hDCMMJQwnDCkMKwwtDC8MMQwzDDUMNww5DDsMPQw/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB/CD+GH8EP4IfwQfgg/hB8KdbXV5Meh5lonP6bVV9Pq2xajNreYCowgwZMXt0nvuEgtXJI74AYqhXhJl3DJlmhJlmDJlVhJlVDJlEhJlEDJkzhJkzDJkihJkiDJkRhJkRBZY1hiWGFYYFhfWF5YXabFpYTMk+/w4PssWbdN2cPbfr2ecv9tl1b2bq+r/Xr3trjbvW+3y8Wv1fb98KWfr6vdob6t9uW/w3Kx3j2XWoDfN9v19Nvn8tR66DdN2Wic5Y7NpXPbRx9pH9NwQXufWvuQ0rF98F/au3575UR7Z/nU/uv9+yvvf+b6LrfwvcXe9cfbXd/73K6fQ+/6aeb6IbQBSCGeemDpIkLSZYTxRIgXEfw5hJkcw9DGISj1cjR3u4EcnWsi2djtQJiZiUHHmXgCjOErYGYqakxtLmvMrouIfUTZUrbpWHaTqYuYGcrsQ8sx9AFzORxXBG/hohyitcmk6IYeQjaTQ4xtNMvuTl2EZhCD2niWg0a4qBf5NBpZ3V7MTMp47EP0XSsUbvd4CdnTfpTvPR4Ub/h8s+ZE/G0Q/tOBufbHiZCGoft8u+EDOqWmQ+7fgNOVPs10oBxb2x2UE+nY7YK/cmlzM9OwbO2bCWVX3zdhvHppc/HKpW0OcOaacGYfYrgoh3Jsbn0oJ9GLRuO8Bdbr6gXWuytH40xAP8o5wJnDOZvDeUv8rJ7x2Anl7hLl0+2WqKLWcTCd+7rM35dPq6fN/uvb6+koF+pRLnKU8/UsJ1cPc4dqVFHdtLOpBzqleqJTrkc6x5nO5XqoO9TCm/aV07HuUI2qabddT3ZhSuzXar9ZPW7XU9+m3r/vnlpXy8e3f17bf9qr+Nf9y9P6+X2/nm7r9D6+8L5FWya7n94ilg/lFdOyvD66b69E//cFFRk1xvvjqX3645iW0d1/TuH9Cw==","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n#[deprecated(\"This functions is deprecated in favour of external verification libraries. To verify Barretenberg proofs, it's recommended to use the library https://github.com/AztecProtocol/aztec-packages/tree/next/barretenberg/noir/bb_proof_verification\")]\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"//mod test_inputs; // test_inputs.nr\nuse poseidon::poseidon2::Poseidon2;\n\n\n/** \n * @notice - Test: Convert IPFS CID (sha256) -> bytes -> Field -> Poseidon2 Hash\n */\npub fn convert_nft_metadata_cid_to_poseidon_hash(metadata_cid: str<46>) -> Field {\n    let metadata_cid: str<46> = metadata_cid;\n    println(metadata_cid);\n\n    let metadata_cid_bytes: [u8; 46] = metadata_cid.as_bytes();\n    println(metadata_cid_bytes);\n\n    let metadata_cid_field = Field::from_be_bytes::<46>(metadata_cid_bytes);\n    println(metadata_cid_field);\n\n    let inputs_for_metadata_cid_field: [Field; 1] = [metadata_cid_field];\n    let metadata_cid_hash = Poseidon2::hash(inputs_for_metadata_cid_field, inputs_for_metadata_cid_field.len());\n    println(metadata_cid_hash);\n\n    metadata_cid_hash\n}\n","path":"/home/sponge-protocol/sponge-protocol-back/circuits/src/converters/converter_module.nr"},"54":{"source":"mod tests;      // tests/mod.nr\nmod data_types; // data_types.nr\nmod converters; // converters.nr \n\nuse poseidon::poseidon2::Poseidon2;\nuse data_types::{ IPNftData, RevealedData }; // @dev - IPNftData struct\n\n\nfn main(\n    root: pub Field,\n    hash_path: [Field; 2],\n    index: Field,\n    secret: Field,\n    expected_nullifier: Field,\n    expected_nft_metadata_cid_hash: Field,\n    ip_nft_data: IPNftData\n//) -> pub Field {\n) -> pub RevealedData {\n    let nft_metadata_cid_hash: Field = converters::converter_module::convert_nft_metadata_cid_to_poseidon_hash(ip_nft_data.nft_metadata_cid);\n    println(nft_metadata_cid_hash); \n\n    // Constraint: nft_metadata_cid_hash == expected_nft_metadata_hash\n    assert(nft_metadata_cid_hash == expected_nft_metadata_cid_hash);\n\n    println(expected_nullifier);\n\n    let inputs_for_note_commitment: [Field; 1] = [secret];\n    let note_commitment = Poseidon2::hash(inputs_for_note_commitment, inputs_for_note_commitment.len());\n\n    //let inputs_for_nullifier: [Field; 1] = [ip_nft_data.nft_token_id];\n    let inputs_for_nullifier: [Field; 5] = [root, secret, ip_nft_data.nft_owner, ip_nft_data.nft_token_id, expected_nft_metadata_cid_hash];\n    let nullifier = Poseidon2::hash(inputs_for_nullifier, inputs_for_nullifier.len());\n    println(nullifier);\n    assert(nullifier == expected_nullifier);\n\n    RevealedData {\n        nullifier,\n        nft_metadata_cid_hash,\n    }\n}","path":"/home/sponge-protocol/sponge-protocol-back/circuits/src/main.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained"]}