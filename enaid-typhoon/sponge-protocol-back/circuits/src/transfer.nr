// Transfer Circuit: Anonymously transfer an NFT commitment to a new owner
// This circuit proves ownership of a commitment and creates a new one for the recipient

use poseidon::poseidon2::Poseidon2;

/**
 * @notice Transfer circuit for anonymous NFT transfers
 * @dev SECURITY FIX: Binds commitments to public keys to prevent griefing
 * @dev Proves:
 *   1. The sender owns a valid commitment in the Merkle tree
 *   2. Generates a nullifier to prevent double-spending
 *   3. Creates a new commitment BOUND to recipient's public key (CRITICAL)
 * 
 * Private inputs:
 * - old_secret: Sender's secret
 * - token_id: The NFT token ID
 * - old_pub_key: Sender's public key (binds old commitment)
 * - merkle_proof: Sibling path in the Merkle tree (20 levels)
 * - leaf_index: Position of the commitment in the tree
 * - new_secret: Recipient's secret (generated by recipient)
 * - new_pub_key: Recipient's public key (CRITICAL: binds new commitment)
 * 
 * Public inputs:
 * - old_root: The Merkle root containing the sender's commitment
 * - nullifier: Unique identifier to prevent double-spending
 * - new_commitment: The new commitment for the recipient
 * 
 * SECURITY: new_pub_key in circuit prevents relayer from changing recipient
 */
fn main(
    // Private inputs - sender's note
    old_secret: Field,
    token_id: Field,
    old_pub_key: Field,  // SECURITY FIX: sender's public key
    
    // Private inputs - Merkle proof
    merkle_proof: [Field; 20],
    leaf_index: Field,
    
    // Private inputs - recipient's note
    new_secret: Field,
    new_pub_key: Field,  // SECURITY FIX: recipient's public key (CRITICAL)
    
    // Public inputs
    old_root: pub Field,
    nullifier: pub Field,
    new_commitment: pub Field
) {
    // Step 1: Compute the old commitment WITH sender's public key
    // SECURITY FIX: commitment = Hash(secret, token_id, pub_key)
    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_pub_key];
    let old_commitment = Poseidon2::hash(
        old_commitment_inputs,
        old_commitment_inputs.len()
    );
    
    // Step 2: Verify the old commitment exists in the Merkle tree
    let computed_root = compute_merkle_root(old_commitment, merkle_proof, leaf_index);
    assert(computed_root == old_root, "Invalid Merkle proof");
    
    // Step 3: Compute and verify the nullifier
    // SECURITY FIX: nullifier = Hash(old_secret, token_id, old_pub_key, "nullify")
    let nullifier_constant = 1; // Constant to differentiate nullifier from commitment
    let nullifier_inputs: [Field; 4] = [old_secret, token_id, old_pub_key, nullifier_constant];
    let computed_nullifier = Poseidon2::hash(
        nullifier_inputs,
        nullifier_inputs.len()
    );
    assert(computed_nullifier == nullifier, "Invalid nullifier");
    
    // Step 4: Compute and verify the new commitment for the recipient
    // SECURITY CRITICAL: This BINDS the new commitment to the recipient's public key
    // Prevents relayers or attackers from re-routing the NFT to themselves
    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_pub_key];
    let computed_new_commitment = Poseidon2::hash(
        new_commitment_inputs,
        new_commitment_inputs.len()
    );
    assert(computed_new_commitment == new_commitment, "Invalid new commitment");
    
    // SECURITY: The proof now enforces that:
    // 1. Sender controls old_pub_key (via old_secret + Merkle proof)
    // 2. New commitment is bound to new_pub_key
    // 3. Only recipient with private key for new_pub_key can spend the note
}

/**
 * @notice Compute Merkle root from leaf and proof
 * @param leaf The leaf commitment
 * @param proof Sibling hashes along the path (20 levels)
 * @param index The leaf index
 * @return The computed Merkle root
 */
fn compute_merkle_root(
    leaf: Field,
    proof: [Field; 20],
    index: Field
) -> Field {
    let mut current_hash = leaf;
    let mut current_index = index;
    
    // Traverse up the tree, hashing with siblings
    for i in 0..20 {
        let sibling = proof[i];
        
        // Determine if current node is left or right child
        // If index is even, we're the left child
        let is_left = (current_index % 2) == 0;
        
        // Hash with sibling in correct order
        let hash_inputs: [Field; 2] = if is_left {
            [current_hash, sibling]
        } else {
            [sibling, current_hash]
        };
        
        current_hash = Poseidon2::hash(hash_inputs, 2);
        
        // Move to parent node
        current_index = current_index / 2;
    }
    
    current_hash
}

#[test]
fn test_transfer_valid() {
    // Setup sender's note
    let old_secret = 12345;
    let token_id = 1;
    let old_view_key = 67890;
    
    // Compute old commitment
    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_view_key];
    let old_commitment = Poseidon2::hash(
        old_commitment_inputs,
        old_commitment_inputs.len()
    );
    
    // Create a simple Merkle proof (all zeros for this test)
    let merkle_proof: [Field; 20] = [0; 20];
    let leaf_index = 0;
    
    // Compute root (just the commitment since all siblings are zero)
    let old_root = compute_merkle_root(old_commitment, merkle_proof, leaf_index);
    
    // Setup recipient's note
    let new_secret = 54321;
    let new_view_key = 98765;
    
    // Compute new commitment
    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_view_key];
    let new_commitment = Poseidon2::hash(
        new_commitment_inputs,
        new_commitment_inputs.len()
    );
    
    // Compute nullifier
    let nullifier_constant = 1;
    let nullifier_inputs: [Field; 4] = [old_secret, token_id, old_view_key, nullifier_constant];
    let nullifier = Poseidon2::hash(
        nullifier_inputs,
        nullifier_inputs.len()
    );
    
    // Should pass with valid inputs
    main(
        old_secret,
        token_id,
        old_view_key,
        merkle_proof,
        leaf_index,
        new_secret,
        new_view_key,
        old_root,
        nullifier,
        new_commitment
    );
}

#[test(should_fail)]
fn test_transfer_invalid_merkle_proof() {
    let old_secret = 12345;
    let token_id = 1;
    let old_view_key = 67890;
    
    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_view_key];
    let old_commitment = Poseidon2::hash(
        old_commitment_inputs,
        old_commitment_inputs.len()
    );
    
    let merkle_proof: [Field; 20] = [0; 20];
    let leaf_index = 0;
    
    // Use wrong root
    let wrong_root = 99999;
    
    let new_secret = 54321;
    let new_view_key = 98765;
    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_view_key];
    let new_commitment = Poseidon2::hash(
        new_commitment_inputs,
        new_commitment_inputs.len()
    );
    
    let nullifier_constant = 1;
    let nullifier_inputs: [Field; 4] = [old_secret, token_id, old_view_key, nullifier_constant];
    let nullifier = Poseidon2::hash(
        nullifier_inputs,
        nullifier_inputs.len()
    );
    
    // Should fail with invalid root
    main(
        old_secret,
        token_id,
        old_view_key,
        merkle_proof,
        leaf_index,
        new_secret,
        new_view_key,
        wrong_root,
        nullifier,
        new_commitment
    );
}

#[test(should_fail)]
fn test_transfer_invalid_nullifier() {
    let old_secret = 12345;
    let token_id = 1;
    let old_view_key = 67890;
    
    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_view_key];
    let old_commitment = Poseidon2::hash(
        old_commitment_inputs,
        old_commitment_inputs.len()
    );
    
    let merkle_proof: [Field; 20] = [0; 20];
    let leaf_index = 0;
    let old_root = compute_merkle_root(old_commitment, merkle_proof, leaf_index);
    
    let new_secret = 54321;
    let new_view_key = 98765;
    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_view_key];
    let new_commitment = Poseidon2::hash(
        new_commitment_inputs,
        new_commitment_inputs.len()
    );
    
    // Use wrong nullifier
    let wrong_nullifier = 88888;
    
    // Should fail with invalid nullifier
    main(
        old_secret,
        token_id,
        old_view_key,
        merkle_proof,
        leaf_index,
        new_secret,
        new_view_key,
        old_root,
        wrong_nullifier,
        new_commitment
    );
}

