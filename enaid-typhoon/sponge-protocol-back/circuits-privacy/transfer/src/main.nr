// Transfer Circuit: Anonymously transfer an NFT commitment to a new owner
// This circuit proves ownership of a commitment and creates a new one for the recipient

use poseidon::poseidon2::Poseidon2;

/**
 * @notice Transfer circuit for anonymous NFT transfers
 * @dev SECURITY FIX: Binds commitments to public keys to prevent griefing
 * @dev Proves:
 *   1. The sender owns a valid commitment in the Merkle tree
 *   2. Generates a nullifier to prevent double-spending
 *   3. Creates a new commitment BOUND to recipient's public key (CRITICAL)
 * 
 * Private inputs:
 * - old_secret: Sender's secret
 * - token_id: The NFT token ID
 * - old_pub_key: Sender's public key (binds old commitment)
 * - merkle_proof: Sibling path in the Merkle tree (20 levels)
 * - leaf_index: Position of the commitment in the tree
 * - new_secret: Recipient's secret (generated by recipient)
 * - new_pub_key: Recipient's public key (CRITICAL: binds new commitment)
 * 
 * Public inputs:
 * - old_root: The Merkle root containing the sender's commitment
 * - nullifier: Unique identifier to prevent double-spending
 * - new_commitment: The new commitment for the recipient
 * 
 * SECURITY: new_pub_key in circuit prevents relayer from changing recipient
 */
fn main(
    // Private inputs - sender's note
    old_secret: Field,
    token_id: Field,
    old_pub_key: Field,  // SECURITY FIX: sender's public key
    
    // Private inputs - Merkle proof
    merkle_proof: [Field; 20],
    leaf_index: Field,
    
    // Private inputs - recipient's note
    new_secret: Field,
    new_pub_key: Field,  // SECURITY FIX: recipient's public key (CRITICAL)
    
    // Public inputs
    old_root: pub Field,
    nullifier: pub Field,
    new_commitment: pub Field
) {
    // Step 1: Compute the old commitment WITH sender's public key
    // SECURITY FIX: commitment = Hash(secret, token_id, pub_key)
    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_pub_key];
    let old_commitment = Poseidon2::hash(old_commitment_inputs, old_commitment_inputs.len());
    
    // Step 2: Verify the old commitment exists in the Merkle tree
    let computed_root = compute_merkle_root(old_commitment, merkle_proof, leaf_index);
    assert(computed_root == old_root, "Invalid Merkle proof");
    
    // Step 3: Compute and verify the nullifier
    // SECURITY FIX: nullifier = Hash(old_secret, token_id, old_pub_key, "nullify")
    let nullifier_constant = 1; // Constant to differentiate nullifier from commitment
    let nullifier_inputs: [Field; 4] = [old_secret, token_id, old_pub_key, nullifier_constant];
    let computed_nullifier = Poseidon2::hash(nullifier_inputs, nullifier_inputs.len());
    assert(computed_nullifier == nullifier, "Invalid nullifier");
    
    // Step 4: Compute and verify the new commitment for the recipient
    // SECURITY CRITICAL: This BINDS the new commitment to the recipient's public key
    // Prevents relayers or attackers from re-routing the NFT to themselves
    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_pub_key];
    let computed_new_commitment = Poseidon2::hash(new_commitment_inputs, new_commitment_inputs.len());
    assert(computed_new_commitment == new_commitment, "Invalid new commitment");
    
    // SECURITY: The proof now enforces that:
    // 1. Sender controls old_pub_key (via old_secret + Merkle proof)
    // 2. New commitment is bound to new_pub_key
    // 3. Only recipient with private key for new_pub_key can spend the note
}

/**
 * @notice Compute Merkle root from leaf and proof
 * @param leaf The leaf commitment
 * @param proof Sibling hashes along the path (20 levels)
 * @param index The leaf index
 * @return The computed Merkle root
 */
fn compute_merkle_root(
    leaf: Field,
    proof: [Field; 20],
    index: Field
) -> Field {
    let mut current_hash = leaf;
    let mut current_index = index;
    
    // Traverse up the tree, hashing with siblings
    for i in 0..20 {
        let sibling = proof[i];
        
        // Determine if current node is left or right child
        // If index is even, we're the left child
        let index_as_u32 = current_index as u32;
        let is_left = (index_as_u32 % 2) == 0;
        
        // Hash with sibling in correct order
        let hash_inputs: [Field; 2] = if is_left {
            [current_hash, sibling]
        } else {
            [sibling, current_hash]
        };
        
        current_hash = Poseidon2::hash(hash_inputs, hash_inputs.len());
        
        // Move to parent node
        current_index = (index_as_u32 / 2) as Field;
    }
    
    current_hash
}

