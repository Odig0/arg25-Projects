{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"296217622658401289","abi":{"parameters":[{"name":"old_secret","type":{"kind":"field"},"visibility":"private"},{"name":"token_id","type":{"kind":"field"},"visibility":"private"},{"name":"old_pub_key","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"new_secret","type":{"kind":"field"},"visibility":"private"},{"name":"new_pub_key","type":{"kind":"field"},"visibility":"private"},{"name":"old_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"new_commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"1919566133504053500":{"error_kind":"string","string":"Invalid new commitment"},"12504151944586406243":{"error_kind":"string","string":"Invalid Merkle proof"},"17824934553683747113":{"error_kind":"string","string":"Invalid nullifier"}}},"bytecode":"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","debug_symbols":"tZpLbhtJEETvwrUWlb/6+CqDgUHL9EAAIQm0ZGBg+O7TVOdrSYsmCDZm4wx9Ol0ZFdEVJen37vvh2+s/Xx8efzz93H356/fu2+nheHz45+vx6X7/8vD0OH3295+7HR9+fTkdDtOndh++Pj31vD8dHl92Xx5fj8e73a/98fXtm34+7x/f6sv+NH213O0Oj9+nOjX88XA8nNGfu/eny/qjMnrLp7WELw3icwdZ72Ch2cClvj/fPj2v68+r9sEKrOhaB7swg1SWINLjljU0qayhWVnrEBfW0JqxhjZWp6jrHYZHNhjRb3heii4slBq3zDAKOyFDV2e4oCaVRQyqYqtqutDCRmcrbAy/pYWLf5Ck3tZisYVrsRtb1PcW46YW7mzIhOpqi9joTqmb7Sltsz8vruI6g8rY7FAtGy16qcGVHr04xnUmvSirqDDh0W5TZixb6tFXW1x6VaguO6oht3Souhxdta++KbRtPbv6ZnfopQ219w01XZWVXdJlgYih9aYG1wjbtgv7IpW1l2U7h62uwrdTGVuZuK5Bi5v0cGWa6Zvflrb9belbReXbRWXb35YX3zJjecu0j5q6+j1lUiDCpK3GEd96ivv2U9zbZnN53/ie8u0xIMpmYYdsFPalBtdG9fJ/CtumlwuyVP0cLv+ePtrfP5w+3VZ3Zfdl2lx5+1en/3eawebic4m51Lm0ufS5jLlIySpZs5GcO00bI541stas527Tq1961jFXLWdxT1WyalbL6lkja8069dPz8z3rmKuVrLk+Y9Cc1HJUy1kth7Wc1nJcy3k95/Xs5zrP4zmv57ye83qd5/Kc13NeH/O6I+eNnDdy3sh5w+f1R2StWXPeyPVFrq/m+mqur+a8NeetOW9lb3PemvPW7FfHvP5WskrWnLfZPEfzrJE196O1rD1rzttz3i7z+rtmtaw5b8/19VxfR325vp7zjpx35Lwj5x0578h5R/Ybqb/RsvasOa+UkoIsAlBA7okUBwSgAhoghSgllShSAALALGIABwSgAhqgA/CgYkJdXEhnxYeKERUnKlZUvKiYUdONYrldYgJQAGwYbFhqVKwCGgA28JFgJMFJ4qzZYcNhw2HDYcNhw2HD6RyFV44AFAAbkbKVCEAFsIPRAaldqbBRYaOmfKUawAGwgcUEjwkmk8qaG2w02Giw0WCjwUaDjUbn1nirdgB67rDR0XNHz90A7GBHzx09d9josNHR80DPAz0P2MB9gv0E/8lgzQM2BmyMZENLAQhAAQZIPWsJQAU0QOpZC6eLFADni3DACCeMcMQIZ4yknlU4ZYRjRpINxYOKBxUPqrJmdUAAKqABOgA2jM6WelZTgAFgw1LPahXQAJ2jdHCWctg6bDhseOpZ3QEBgA08qHhQ8aAGaw7YCNgI2AjYCNgI2Ag6R+pZI/WstQBgo6aetRrAAUtKICbUBoCNChst9axNAAqADTyoeFDxoDbW3GCjwUaHjQ4bHTY6bHQ6d/Tc0XNHzx02Onoe6HkIgB0c6Hmg5wEbAzYGeh5LbFpyE8EJDxoeNDxohfBUSE+F+FTIT4UAVZINIzIamdEk9WykRiM2GrnRJPVsJEcjOprkDhrh0UiPRnw08qNp6tk0ABXQAKwZDxoetCVHvgdJ2Fii5JIllzC5pMklTlrq2bwABAAbnno2d0AAcgfNG6ADYINoaZF6tlCAAWADDxoeNDxoREwjYxoh00iZRsw0cqYRNK0uyTr1bLUBOgA2WurZmgAUwA42BwQANkid1lLP1tBzR88kT8ODhgcNDxrp04if1pf7AGyQQI0IamRQI4TaQM8DPQ/0TBC1gZ4Heh7pbi+5g14EoAADOCD17KUCGqADuMXIco3hHkMWdbKok0WdLOpkUSeLOlnUyaKuqWdXAXBFIou6pp5dA8A1SXMHXTsg9exkUSeLuqWe3QzgANjAg44HHQ/6cqdbLnXLrY4s6mRRJ4s6WdTJou6pZ/cOSD07WdQj9eyhAAOwgxGACoANsqhH6tlrAQgANvCg40HHg04WdbKok0WdLOpkUSeLOlnUyaLeuOY27rmtAmCjcdVt6LkXADvY0XNHz2RRJ4t6R88dPXf0TBZ1POh40PGgk0WdLOpkUSeLOlnUyaJOFg2yaJTUcxQFGMABqecoFdAAuYNRuPnLcvXn7k8WDUk9h3D9F+7/ZNHAg4EHAw8GWTTIokEWDbJokEWDLBpk0SCLhqaeQ1PPYQUAG5Z6DjOAA3IHwyqgAWCDLBpvWbSewdTZzp3PHpyBnX/legYOiPNvUM9g6hxv3zN1jvNP3n7tTw/7b8fDz/nvMX68Pt5/+POMl3+f+Qp/wPF8ero/fH89Hc4/HHv72vTjsv8A","file_map":{"50":{"source":"// Transfer Circuit: Anonymously transfer an NFT commitment to a new owner\n// This circuit proves ownership of a commitment and creates a new one for the recipient\n\nuse poseidon::poseidon2::Poseidon2;\n\n/**\n * @notice Transfer circuit for anonymous NFT transfers\n * @dev SECURITY FIX: Binds commitments to public keys to prevent griefing\n * @dev Proves:\n *   1. The sender owns a valid commitment in the Merkle tree\n *   2. Generates a nullifier to prevent double-spending\n *   3. Creates a new commitment BOUND to recipient's public key (CRITICAL)\n * \n * Private inputs:\n * - old_secret: Sender's secret\n * - token_id: The NFT token ID\n * - old_pub_key: Sender's public key (binds old commitment)\n * - merkle_proof: Sibling path in the Merkle tree (20 levels)\n * - leaf_index: Position of the commitment in the tree\n * - new_secret: Recipient's secret (generated by recipient)\n * - new_pub_key: Recipient's public key (CRITICAL: binds new commitment)\n * \n * Public inputs:\n * - old_root: The Merkle root containing the sender's commitment\n * - nullifier: Unique identifier to prevent double-spending\n * - new_commitment: The new commitment for the recipient\n * \n * SECURITY: new_pub_key in circuit prevents relayer from changing recipient\n */\nfn main(\n    // Private inputs - sender's note\n    old_secret: Field,\n    token_id: Field,\n    old_pub_key: Field,  // SECURITY FIX: sender's public key\n    \n    // Private inputs - Merkle proof\n    merkle_proof: [Field; 20],\n    leaf_index: Field,\n    \n    // Private inputs - recipient's note\n    new_secret: Field,\n    new_pub_key: Field,  // SECURITY FIX: recipient's public key (CRITICAL)\n    \n    // Public inputs\n    old_root: pub Field,\n    nullifier: pub Field,\n    new_commitment: pub Field\n) {\n    // Step 1: Compute the old commitment WITH sender's public key\n    // SECURITY FIX: commitment = Hash(secret, token_id, pub_key)\n    let old_commitment_inputs: [Field; 3] = [old_secret, token_id, old_pub_key];\n    let old_commitment = Poseidon2::hash(old_commitment_inputs, old_commitment_inputs.len());\n    \n    // Step 2: Verify the old commitment exists in the Merkle tree\n    let computed_root = compute_merkle_root(old_commitment, merkle_proof, leaf_index);\n    assert(computed_root == old_root, \"Invalid Merkle proof\");\n    \n    // Step 3: Compute and verify the nullifier\n    // SECURITY FIX: nullifier = Hash(old_secret, token_id, old_pub_key, \"nullify\")\n    let nullifier_constant = 1; // Constant to differentiate nullifier from commitment\n    let nullifier_inputs: [Field; 4] = [old_secret, token_id, old_pub_key, nullifier_constant];\n    let computed_nullifier = Poseidon2::hash(nullifier_inputs, nullifier_inputs.len());\n    assert(computed_nullifier == nullifier, \"Invalid nullifier\");\n    \n    // Step 4: Compute and verify the new commitment for the recipient\n    // SECURITY CRITICAL: This BINDS the new commitment to the recipient's public key\n    // Prevents relayers or attackers from re-routing the NFT to themselves\n    let new_commitment_inputs: [Field; 3] = [new_secret, token_id, new_pub_key];\n    let computed_new_commitment = Poseidon2::hash(new_commitment_inputs, new_commitment_inputs.len());\n    assert(computed_new_commitment == new_commitment, \"Invalid new commitment\");\n    \n    // SECURITY: The proof now enforces that:\n    // 1. Sender controls old_pub_key (via old_secret + Merkle proof)\n    // 2. New commitment is bound to new_pub_key\n    // 3. Only recipient with private key for new_pub_key can spend the note\n}\n\n/**\n * @notice Compute Merkle root from leaf and proof\n * @param leaf The leaf commitment\n * @param proof Sibling hashes along the path (20 levels)\n * @param index The leaf index\n * @return The computed Merkle root\n */\nfn compute_merkle_root(\n    leaf: Field,\n    proof: [Field; 20],\n    index: Field\n) -> Field {\n    let mut current_hash = leaf;\n    let mut current_index = index;\n    \n    // Traverse up the tree, hashing with siblings\n    for i in 0..20 {\n        let sibling = proof[i];\n        \n        // Determine if current node is left or right child\n        // If index is even, we're the left child\n        let index_as_u32 = current_index as u32;\n        let is_left = (index_as_u32 % 2) == 0;\n        \n        // Hash with sibling in correct order\n        let hash_inputs: [Field; 2] = if is_left {\n            [current_hash, sibling]\n        } else {\n            [sibling, current_hash]\n        };\n        \n        current_hash = Poseidon2::hash(hash_inputs, hash_inputs.len());\n        \n        // Move to parent node\n        current_index = (index_as_u32 / 2) as Field;\n    }\n    \n    current_hash\n}\n\n","path":"/home/sponge-protocol/sponge-protocol-back/circuits-privacy/transfer/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}