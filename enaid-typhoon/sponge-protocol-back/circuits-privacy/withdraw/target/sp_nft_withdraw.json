{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"16465083666091943792","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"token_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner_pub_key","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"token_id_public","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"5648385508649339024":{"error_kind":"string","string":"Token ID mismatch"},"12504151944586406243":{"error_kind":"string","string":"Invalid Merkle proof"},"17824934553683747113":{"error_kind":"string","string":"Invalid nullifier"}}},"bytecode":"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","debug_symbols":"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","file_map":{"50":{"source":"// Withdraw Circuit: Unshield an NFT from the privacy pool\n// This circuit proves ownership of a commitment and allows withdrawal to a public address\n\nuse poseidon::poseidon2::Poseidon2;\n\n/**\n * @notice Withdraw circuit for unshielding NFTs\n * @dev SECURITY FIX: Commitment bound to public key\n * @dev Proves:\n *   1. The owner controls a valid commitment in the Merkle tree\n *   2. Generates a nullifier to mark the note as spent\n *   3. Reveals the token_id and recipient address\n * \n * Private inputs:\n * - secret: Owner's secret\n * - owner_pub_key: Owner's public key (binds commitment)\n * - merkle_proof: Sibling path in the Merkle tree (20 levels)\n * - leaf_index: Position of the commitment in the tree\n * \n * Public inputs:\n * - root: The Merkle root containing the commitment\n * - nullifier: Unique identifier to prevent double-spending\n * - token_id: The NFT token ID being withdrawn (revealed)\n * - recipient: The public address to receive the NFT (revealed)\n * \n * SECURITY: Commitment is bound to owner_pub_key\n */\nfn main(\n    // Private inputs\n    secret: Field,\n    token_id: Field,\n    owner_pub_key: Field,  // SECURITY FIX: Bind to owner\n    merkle_proof: [Field; 20],\n    leaf_index: Field,\n    \n    // Public inputs\n    root: pub Field,\n    nullifier: pub Field,\n    token_id_public: pub Field,\n    recipient: pub Field\n) {\n    // Step 1: Verify token_id matches public token_id\n    assert(token_id == token_id_public, \"Token ID mismatch\");\n    \n    // Step 2: Compute the commitment WITH owner's public key\n    // SECURITY FIX: commitment = Hash(secret, token_id, owner_pub_key)\n    let commitment_inputs: [Field; 3] = [secret, token_id, owner_pub_key];\n    let commitment = Poseidon2::hash(commitment_inputs, commitment_inputs.len());\n    \n    // Step 3: Verify the commitment exists in the Merkle tree\n    let computed_root = compute_merkle_root(commitment, merkle_proof, leaf_index);\n    assert(computed_root == root, \"Invalid Merkle proof\");\n    \n    // Step 4: Compute and verify the nullifier\n    // SECURITY FIX: nullifier = Hash(secret, token_id, owner_pub_key, \"nullify\")\n    let nullifier_constant = 1; // Same constant as in transfer circuit\n    let nullifier_inputs: [Field; 4] = [secret, token_id, owner_pub_key, nullifier_constant];\n    let computed_nullifier = Poseidon2::hash(nullifier_inputs, nullifier_inputs.len());\n    assert(computed_nullifier == nullifier, \"Invalid nullifier\");\n    \n    // Step 5: No need to verify recipient - it's a public input\n    // The contract will transfer the NFT to the recipient address\n    // We just need to prove we own the commitment bound to owner_pub_key\n}\n\n/**\n * @notice Compute Merkle root from leaf and proof\n * @param leaf The leaf commitment\n * @param proof Sibling hashes along the path (20 levels)\n * @param index The leaf index\n * @return The computed Merkle root\n */\nfn compute_merkle_root(\n    leaf: Field,\n    proof: [Field; 20],\n    index: Field\n) -> Field {\n    let mut current_hash = leaf;\n    let mut current_index = index;\n    \n    // Traverse up the tree, hashing with siblings\n    for i in 0..20 {\n        let sibling = proof[i];\n        \n        // Determine if current node is left or right child\n        let index_as_u32 = current_index as u32;\n        let is_left = (index_as_u32 % 2) == 0;\n        \n        // Hash with sibling in correct order\n        let hash_inputs: [Field; 2] = if is_left {\n            [current_hash, sibling]\n        } else {\n            [sibling, current_hash]\n        };\n        \n        current_hash = Poseidon2::hash(hash_inputs, hash_inputs.len());\n        \n        // Move to parent node\n        current_index = (index_as_u32 / 2) as Field;\n    }\n    \n    current_hash\n}\n\n","path":"/home/sponge-protocol/sponge-protocol-back/circuits-privacy/withdraw/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}